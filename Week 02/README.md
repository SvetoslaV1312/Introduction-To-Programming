# Условни оператори.<br>Оператори за цикъл

<slidebreak/>

## Условни оператори

- Предоставят разклонение в логиката на програмата
- Винаги оценяваме дадено булево условие

```cpp
if(<condition>) <operation>
```

```cpp
int x = 42;
if(x % 2 == 0) std::cout << "x is even";
```

<slidebreak/>

- Може да добавяме и какво да се случи ако не влезем в това разклонение

```cpp
if(<condition>) <operation 1>
else <operation 2>
```

```cpp
int x = 42;
if(x % 2 == 0) std::cout << "x is even";
else std::cout << "x is odd";
```

> [!NOTE]
> Влизаме или само в операция 1 или само в операция 2

<slidebreak/>

- Може да добавяме и множество разклонения

```cpp
if(<condition 1>) <operation 1>
else if(<condition 2>) <operation 2>
...
else if(<condition n>) <operation n>
else <operation n+1>
```

```cpp
int x = 42;
if(x > 0) std::cout << "x is positive";
else if(x < 0)  std::cout << "x is negative";
else std::cout << "x is zero";
```

> [!NOTE]
> Винаги влизаме само в едно разклонение и надолу проверките спират, ако все още има такива

<slidebreak/>

- Операцията може да бъде цял блок, обособяващ в себе си и повече от една операция

```cpp
int x = 42;
int result;
if(x > 0)
{
    std::cout << "x is positive";
    result = 2;
}
else if(x < 0)
{
    std::cout << "x is negative";
    result = 1;
}
else
{
    std::cout << "x is zero";
    result = 0;
}
```

> [!NOTE]
> Обикновено, дори да имаме само 1 операция, винаги създаваме scope за условия оператор, за по-голяма четимост

<slidebreak/>

- Когато имаме по-сложна логика на програмата можем да правим и вложени проверки

```cpp
int x = 42;
if(x > 0)
{
    if(x%2==0) std::cout << "x is positive and even";
    else std::cout << "x is positive and odd";
}
else if(x < 0)
{
    if(x%2==0) std::cout << "x is negative and even";
    else std::cout << "x is negative and odd";
}
else
{
    std::cout << "x is zero";
}
```

> [!IMPORTANT]
> Трето ниво на влагане на проверки обикновено означава недобре структуриран код

<slidebreak/>

### switch-case

- Подобно на `if`, можем да правим проверки, но за дадени стойности
- Имаме експлицитно ограничение стойностите на кои типове можем да сравняваме - `int`, `char`, `bool`, `enum`(??)
- Използваме оператор `break` за прекъсване на изпълнението на оператора, ако намерим попадение
- Използваме ключовата дума `default` за случай, в който не намерим попадение преди това

```cpp
switch(<value>)
{
	case <value 1>: <instruction 1> break;
	case <value 2>: <instruction 1> break;
    // ...
	case <value n>: <instruction n> break;
	default: <instruction n+1> break;
}
```

<slidebreak/>

- По принцип подреждаме по вероятност на случаите стойностите за проверка
- Ако не ползваме `break`, то ще пропаднем надолу по случаите, дори без да има попадение
- `default` случаят се разглежда последен винаги, независимо от позицията си в тялото на `switch`. За четимост винаги го пишем последен!
- След последния случай в тялото може да не пишем оператор `break`, понеже няма накъде да пропаднем повече. За четимост може да го пишем!
- Операциите на случаите може да са цели блокове

> [!WARNING]
> Ако искаме да декларираме променливи в даден случай, задължително ни трябва нов block scope. Изключение е, ако случаят е последен. Защо?

<slidebreak/>

- Switch vs if

```cpp
int x = 42;

switch(x)
{
    case 1 : std::cout<<"one"; break;
    case 2 : std::cout<<"two"; break;
    case 3 : std::cout<<"three"; break;
    case 4 : std::cout<<"four"; break;
    default : std::cout<<"idk"; break;
}

if(x==1) std::cout<<"one";
else if(x==2) std::cout<<"two";
else if(x==3) std::cout<<"three";
else if(x==4) std::cout<<"four";
else std::cout<<"idk";
```

- Компилаторът прави оптимизация, генерирайки jump tree за `switch`, което предполага по-бързо изпълнение. Това в днешно време не е задължително да е предимство пред `if`, понеже различните компилатори на различен код правят различни оптимизации и е възможно `if` да се справя дори по-добре.
- `switch` е подходящ, когато проверяваме за конкретни стойности на променлива, в случаите когато са повече от 2 възможни разклонения. Във всички останали случаи предпочитаме `if`.

<slidebreak/>

- Пример за пропадане

```cpp
switch(x)
{
    case 1 : std::cout<<"one";
    case 5 : std::cout<<"five";
    case 3 : std::cout<<"three"; break;
    case 2 : std::cout<<"two";
    case 4 : std::cout<<"four"; break;
    case 6 : std::cout<<"three";
    default : std::cout<<"idk"; break;
}
```

- Пример за декларация на променлива

```cpp
int y = 24;
switch(x)
{
    // case 3 : int y = 42; std::cout<<"three"; break;
    case 3 : { int y = 42; std::cout<<"three"; break; }
    case 4 : std::cout<<"four"; break;
    default : int y = 42; std::cout<<"idk"; break;
}
```

<slidebreak/>

> [!IMPORTANT]
> Тялото на произволна клауза може да е празно. Това на практика не се ползва.

```cpp
int x = 42;
if(x==0);
else if(x==5) std::cout<<"five";
else if(x==10);
else;
```

```cpp
int x = 42;
switch(x)
{
    case 1 : break;
    case 2 : ;
    case 3 : std::cout<<"three";
    case 4 : ;
    default : std::cout<<"idk" break;
}
```

<slidebreak/>

- Разлики с тернарен оператор
  - Връщане на стойност
  - Изпълнение на множество инструкции

```cpp
if(x % 2 == 0) std::cout << "even\n";
else std::cout << "odd\n";

std::cout << (x % 2 == 0 ? "even" : "odd") << "\n";
```

```cpp
int x = 42, y = 42;
double z = 5;
if(x%2 == 0) y+=2;
else z+=1;

x%2 == 0 ? y+=2 : z+= 1;
```

> [!WARNING]
> Тернарен оператор ползваме, когато искаме да върнем стойност

<slidebreak/>

> [!CAUTION]
> Всяка програма, която ползва множество `if` проверки, може да се представи като програма, която използва множество `switch` проверки. Това е важно едниствено с цел за разбирането на принципа на работа на условните оператори, не е от практическо значение. Възможно е и представянето на програмата единствено с тернарни оператори, като това изкривява тотално смисъла на операторите.

<slidebreak/>

## Оператори за цикъл

- Цикълът е процес, представляващ многократното изпълнение на дадена последователност от операции с определени данни
- В общия смикъл е операция, която се изпълнява определен брой пъти
- Цикличния процес може да **ИМА** предварително известен брой повторения - тогава той е **индуктивен** процес
- Цикличния процес може да **НЯМА** предварително известен брой повторения - тогава той е **итеративен** процес

<slidebreak/>

### Оператор while

```cpp
while(<condition>) <operation>
```

- Изпълнява операцията, докато булевото условие е истина
- Операцията в общия случай трябва да променя някакви данни, за да може условието в даден момент да стане лъжа
- Може операцията да е цял блок, представялващ нов scope. За прегледност винаги пишем блок!
- Оценява се условието, изпълнява се тялото, оценява се условието, изъплянава се тялото, оценява се условието, ..., оценява се условието
- Можем да създаваме и безкрайни цикли, което не е приложимо в практиката...

<slidebreak/>

```cpp
while(true) std::cout << "Infinite loop";

int i = 0;
while(i <= 100)
{
    std::cout << i << std::endl;
    ++i;
}
```

<slidebreak/>

> [!IMPORTANT]
> По принцип префиксната инкрементация е по-оптимална от постфиксната и може да направи някаква оптимизация. Защо?

<slidebreak/>

- Поведението на цикъла може да се контролира и от оператор `break` - когато го използваме някъде в тялото на цикъла изпълнението спира до този ред и условието повече не се оценява
- Друг оператор е `continue` - при него спираме изпълнението на тялото на цикъла и отиваме директно на следващата оценка на условието

> [!NOTE]
> Когато имаме цикли, които имат по-сложни условия за финал (които по-лесно могат да се оценят в тялото на цикъла) обикновено правим безкраен цикъл и в тялото ползваме `break`

<slidebreak/>

```cpp
int i = 0;

while(true)
{
    std::cout << i << std::endl;
    if(i==100) break;
    ++i;
}
```

```cpp
int i = 0;

while(true)
{
    if(i==101) break;
    ++i;
    if(i%2==1) continue;
    std::cout << i << std::endl;
}
```

> [!CAUTION]
> От съществено значение е мястото, на което ползваме `break` и `continue`

<slidebreak/>

### Оператор do-while

- Различава се от оператор `while` с това, че **тялото се изпълнява поне веднъж**

```cpp
do <operation> while(<condition>);
```

- Операцията може и трябва да е отделен блок
- Изпълнява се тялото, оценява се условието, изъплянава се тялото, оценява се условието, ..., оценява се условието

```cpp

int i = 0;
do
{
    std::cout << i << std::endl;
}
while(i <= 10);

```

<slidebreak/>

### Оператор for

```cpp
for(<init-statement>; <condition>; <expression>) <operation>
```

- Улеснява рабоата, еквивалентен на

```cpp
{
    <init-statement>;
    while(<condition>)
    {
        <operation>;
        <expression>;
    }
}
```

- Инициализация, условие, тяло, инкрементация, условие, тяло, инкрементация, условие, тяло, инкрементация, ..., условие

<slidebreak/>

```cpp
for(;;); // Infinite loop
```

```cpp
for(int i = 0; i <= 100; ++i)
{
    std::cout << i << std::end;
}
```

```cpp
for(int i = 0; i <= 100; i+=2)
{
    std::cout << i << std::end;
}
```

```cpp
int i = 0;

for (std::cout << "initialize\n"; ((std::cout << "checking i=" << i << std::endl), i <= 5); std::cout<<"incrementing\n", i+=2 )
{
    std::cout<<i<< std::endl;
}
```

<slidebreak/>

> [!IMPORTANT]
> Всички оператори за цикли са взаимно заменяеми. Всеки трябва да може да пише еквивалентния код с друг оператор.

> [!IMPORTANT]
> Обикновено ползваме `for` за индуктивни процеси, `while` за итеративни, а `do-while` не ползваме.
> Важно е да напишем цикъла по разбираем и подходящ начин.

> [!IMPORTANT]
> Когато имаме повторение на код, трябва или да изнесем общата логика от разклоненията, или да направим цикъл. По-нататък ще разберем и други възможности за справяне с този проблем.

> [!NOTE]
> Въпроси?
